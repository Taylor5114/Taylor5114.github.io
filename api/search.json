[{"id":"d6feb60dc8b0767ab3228d0e2eb4697d","title":"vue-cropper","content":"Vue-cropper\n使用方式\n\n","slug":"vue-cropper","date":"2022-05-30T07:45:34.000Z","categories_index":"","tags_index":"vue插件","author_index":"Raver233"},{"id":"5cba447cee2fc5ef4c149e53578b4c7c","title":"FrontEnd","content":"默认配置\n\n指定浏览器使用webkit内核解析页面\n","slug":"FrontEnd","date":"2022-01-22T09:29:19.000Z","categories_index":"","tags_index":"","author_index":"Raver233"},{"id":"8aa9bb0438939ce2b4a00f1a6ea1e9e5","title":"Go","content":"学习 狗语言Go语言文件的基本结构package main\n\n&#x2F;&#x2F; 导入语句\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; 函数外面只能定义标识符(变量)、函数、类型\n&#x2F;&#x2F; fmt.Println(&quot;我不是张三&quot;)  不能执行语句\n\n&#x2F;&#x2F; 程序的入口函数\nfunc main() &#123;\n\tfmt.Println(&quot;Hello, World!&quot;)\n\tfmt.Println(&quot;你好，世界&quot;)\n&#125;\n\n标识符由字母、数字、_ 组成，只能以字母开头\n变量和常量9go语言中的变量必须先声明再使用\n声明变量var name string  &#x2F;&#x2F; 声明一个保存字符串类型数据的变量\nvar age int\nvar flag bool\n\n批量声明var (\n\tname string\n  age int\n  flag bool\n)\n\n\n\n","slug":"Go","date":"2021-12-10T15:36:48.000Z","categories_index":"","tags_index":"Go","author_index":"Raver233"},{"id":"8e30f2149bb0b74d970e05c27cce2051","title":"VsCode","content":"快捷键\n选中编辑代码中相同的内容 command/ctrl+shift+L\n\n","slug":"VsCode","date":"2021-11-22T01:43:04.000Z","categories_index":"","tags_index":"","author_index":"Raver233"},{"id":"3a4eda1192ec992162144e15ab7e2ec5","title":"Vue3","content":"常用的Compositon APIsetup函数\n理解：vue3.0中一个新的配置项，值为一个函数\n\nsetup执行的时机\n\n在beforeCreate之前执行一次，this是undefined\n\n\nsetup的参数\n\nprops：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性\ncontent：上下文对象\nattrs：值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性，相当于 this.$attrs\nslots：收到的插槽内容，相当于 this.$slots\nemit：分发自定义事件的函数，相当于 this.$emit\n\n\n\n\nsetup是所有Composition API（组合式API）的容器\n\n组件中所用到的：数据、方法等等，均要配置在setup中\n\nsetup函数的两种返回值：\n\n若返回一个对象，则对象中的属性、方法，在模板中均可以直接使用。（重点！）\n若返回一个渲染函数：则可以自定义渲染内容（了解）\n\n\n注意点：\n\n尽量不要与Vue2.x配置混用\nVue2.x配置（data、methods、computed…）中可以访问到setup中的属性、方法\n但在setup中不能访问到Vue2.x配置（data、methods…)\n如果有重名 setup优先\n\n\nsetup不能是一个async函数，因为返回值不再是return的对象，而是promise，模板看不到return对象中的属性（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）\n\n\n\nref函数\n作用：定义一个响应式数据\n\n语法：\nconst xxx &#x3D; ref(initValue)\n\n\n创建一个包含响应式数据的应用对象（reference对象）\nJS中操作数据：\n\nxxx.value\n\n\n模板中读取数据：不需要value，直接：\n\n&lt;p&gt;&#123;&#123;xxx&#125;&#125;&lt;&#x2F;p&gt;\n备注：\n\n接收的数据可以是：基本类型、也可以是对象类型\n基本类型的数据：响应式依靠的是 Object.definePropetry() 的 get 与 set 完成的\n对象类型的数据：内部“求助”了Vue3.0中的一个新函数——reactive函数\n\n\n\nreactive函数\n作用：定义一个对象类型的响应式数据（不能用来定义基本类型）\n\n语法：\nconst 代理对象 &#x3D; reactive(源对象)\n\n接收一个对象（或数组），返回一个代理对象（proxy对象）\n\nreactive定义的响应式数据是“深层次的”\n\n内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据进行操作\n\n\nVue3.0中的响应式原理vue2.x的响应式\n实现原理：\n\n对象类型：通过 Object.defineProperty() 对属性的读取、修改进行拦截（数据劫持）\n\n数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）\nObject.defineProperty(data,&#39;count&#39;,&#123;\n  get () &#123;&#125;,\n  set () &#123;&#125;\n&#125;)\n\n\n存在问题：\n\n新增属性、删除属性，界面不会更新\n直接通过下标修改数组，界面不会更新\n\n\n\nvue3.0的响应式\n实现原理：\n通过proxy（代理）：拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等\n通过Reflect（反射）：对被代理对象的属性进行操作\n\n\n\nwatchEffect函数\nwatch的套路是：既要指明监视的属性，也要指明监视的回调\nwatchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，就监视哪个属性\nwatchEffect有点像computed：\n但conputed注重的是计算出来的值（回调函数的返回值），所以必须要写返回值\n而watchEffect跟注重的是过程（回调函数的函数体），所以不用写返回值\n\n\n\n自定义hook函数\n本质是一个函数，把setup函数中使用的Composition API进行封装\n类似于vue2中的mixin\n自定义hook的优势：复用代码，让setup中的逻辑更清楚易懂\n\ntoRef\n作用：创建一个ref对象，其value值指向另一个对象中的某个属性\n\n语法：\nconst name &#x3D; toRef(person,&#39;name&#39;)\nconst salary &#x3D; toRef(person.job.j1,&#39;salary&#39;)\n应用：要将响应式独享中的某个属性单独提供给外部使用时\n\n扩展：toRefs与toRef功能一致，但可以批量创建多个ref对象\n\n语法：\nreturn &#123;\n  ...toRefs(person)\n&#125;\n\n\n\n其他 Composition API\nshallowReactive与shallowRef（用于性能优化）\n\nshallowReactive：只处理对象最外层属性的响应式（浅响应式）\nshallowRef：只处理基本数据类型的响应式，不进行对象的响应式处理\n使用：\n如果有一个对象数据，结构比较深，但变化时只是外层属性变化===&gt; shallowReactive\n如果有一个数据对象，后续功能不会修改该对象中的属性，而是生成新的对象来替换===&gt; shallowRef\n\n\n\n\nreadonly与shallowReadonly\n\nreadonly：让一个响应式数据变为只读的（深只读）\nshallowReadonly：让一个响应式数据变为只读的（浅只读：深层次的数据仍可修改）\n应用场景，不希望数据被修改时\n\n\ntoRaw与markRaw\n\ntoRaw\n作用：将一个由 reactive 生成的响应式对象转为普通对象\n使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新\n\n\nmarkRaw\n作用：标记一个对象，使其永远不会成为响应式对象\n应用场景\n有些值不应被设置为响应式的，例如复杂的第三方类库等\n但渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能\naxios\n\n\n\n\n\n\ncustomRef\n\n作用：创建一个自定义的ref，并对其依赖项跟踪和更新出发进行显式控制\n\n实现防抖效果：\n&#x2F;&#x2F;   自定义一个ref 实现防抖功能\n    function myRef(value, delay) &#123;\n      let timer;\n      return customRef((track, trigger) &#x3D;&gt; &#123;\n        return &#123;\n          get() &#123;\n            track(); &#x2F;&#x2F; 通知vue追踪数据的变化\n            return value;\n          &#125;,\n          set(newValue) &#123;\n            clearTimeout(timer);\n            value &#x3D; newValue;\n            timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n              trigger(); &#x2F;&#x2F; 通知vue去重新解析模板\n            &#125;, delay);\n          &#125;,\n        &#125;;\n      &#125;);\n    &#125;\n\n    let keyword &#x3D; myRef(&quot;&quot;, 500);\n\n\n作用：实现祖与后代组件间通信\n\n套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\n\n具体写法：\n\n祖组件中：\nsetup()&#123;\n    ......\n    let car &#x3D; reactive(&#123;name:&#39;奔驰&#39;,price:&#39;40万&#39;&#125;)\n    provide(&#39;car&#39;,car)\n    ......\n&#125;\n后代组件中：\nsetup(props,context)&#123;\n    ......\n    const car &#x3D; inject(&#39;car&#39;)\n    return &#123;car&#125;\n    ......\n&#125;\n\n\n\n\nprovide 与 inject\n\n\n\n\n作用：实现祖与后代组件间通信\n\n套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\n\n具体写法：\n\n祖组件中：\nsetup()&#123;\n    ......\n    let car &#x3D; reactive(&#123;name:&#39;奔驰&#39;,price:&#39;40万&#39;&#125;)\n    provide(&#39;car&#39;,car)\n    ......\n&#125;\n后代组件中：\nsetup(props,context)&#123;\n    ......\n    const car &#x3D; inject(&#39;car&#39;)\n    return &#123;car&#125;\n    ......\n&#125;\n\n\n\n新的组件\nFragment\n\n在vue2中：组件不许有一个根标签\n在vue3中：组件可以没有根标签，内部会将对个标签包含在一个Fragment虚拟元素中\n好处：减少标签层级，减少内存占用\n\n\nTeleport\n\n什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。\n&lt;teleport to&#x3D;&quot;移动位置&quot;&gt;\n\t&lt;div v-if&#x3D;&quot;isShow&quot; class&#x3D;&quot;mask&quot;&gt;\n\t\t&lt;div class&#x3D;&quot;dialog&quot;&gt;\n\t\t\t&lt;h3&gt;我是一个弹窗&lt;&#x2F;h3&gt;\n\t\t\t&lt;button @click&#x3D;&quot;isShow &#x3D; false&quot;&gt;关闭弹窗&lt;&#x2F;button&gt;\n\t\t&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;teleport&gt;\n\n\nSuspense\n\n等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n\n使用步骤：\n\n异步引入组件\nimport &#123;defineAsyncComponent&#125; from &#39;vue&#39;\nconst Child &#x3D; defineAsyncComponent(()&#x3D;&gt;import(&#39;.&#x2F;components&#x2F;Child.vue&#39;))\n使用Suspense包裹组件，并配置好default 与 fallback\n&lt;template&gt;\n    &lt;div class&#x3D;&quot;app&quot;&gt;\n        &lt;h3&gt;我是App组件&lt;&#x2F;h3&gt;\n        &lt;Suspense&gt;\n            &lt;template v-slot:default&gt;\n                &lt;Child&#x2F;&gt;\n            &lt;&#x2F;template&gt;\n            &lt;template v-slot:fallback&gt;\n                &lt;h3&gt;加载中.....&lt;&#x2F;h3&gt;\n            &lt;&#x2F;template&gt;\n        &lt;&#x2F;Suspense&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n\n\n\n\n","slug":"Vue3","date":"2021-11-21T08:29:09.000Z","categories_index":"","tags_index":"vue vue3","author_index":"Raver233"},{"id":"a6ae49244c61aefa5ffa97d9544305fe","title":"vue学习笔记","content":"基础$nextTick作用：在下一次DOM更新结束后执行其指定的回调\n用法：常用于改变数据后，要基于更新后的DOM进行某些操作时，要在nextTick的回调中执行\n&#x2F;&#x2F; 语法\nthis.$nextTick(callback())\n\n路由生命周期钩子activated在路由组件被激活时调用（显示）\ndeactivated在路由组件失活时调用 （隐藏）\n组件传值父传子&lt;tt-child :fun&#x3D;&quot;fun&quot; :obj&#x3D;&quot;obj&quot; :name&#x3D;&quot;name&quot; tips&#x3D;&quot;提示文字&quot;&gt;&lt;&#x2F;tt-child&gt;\n\ndata()&#123;\n  return&#123;\n    name: &#39;Taulor&#39;,\n    obj:&#123;\n\t\t\tage: 31,\n      sex: &#39;女&#39;\n    &#125;\n  &#125;\n&#125;,\nmethods:&#123;\n  fun()&#123;\n    console.log(&#39;fun()&#39;)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 子组件\nprops:[&#39;fun&#39;,&#39;obj&#39;,&#39;name&#39;,&#39;tips&#39;]   &#x2F;&#x2F; 简写，不可以添加类型限制\nprops:&#123;                             &#x2F;&#x2F; 完整写法\n  fun: Function,  &#x2F;&#x2F; 限制类型\n  obj: &#123;\n\t\trequired: true  &#x2F;&#x2F; 限制必传\n  &#125;,\n  name:&#123;\n    type: String,\n    default: &#39;user name&#39;  &#x2F;&#x2F; 默认值\n  &#125;\n&#125;,\nmounted()&#123;\n  this.fun()  &#x2F;&#x2F; 调用父组件传的fun方法\n&#125;\n\n\n子传父&lt;!--子组件--&gt;\n&lt;el-upload\n           name&#x3D;&#39;image&#39;\n           :action&#x3D;&#39;$store.state.host + &quot;&#x2F;business.php&#x2F;Common&#x2F;upload&quot;&#39;\n           :headers &#x3D; token\n           :on-success&#x3D;&quot;handleAvatarSuccess&quot;\n           &gt;\n  &lt;img v-if&#x3D;&quot;imageUrl&quot; :src&#x3D;&quot;imageUrl&quot; class&#x3D;&quot;avatar&quot; &#x2F;&gt;\n  &lt;i v-else class&#x3D;&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;&#x2F;i&gt;\n&lt;&#x2F;el-upload&gt;\n\nmethods: &#123;\n    handleAvatarSuccess(res, file) &#123;\n      this.imageUrl &#x3D; URL.createObjectURL(file.raw);\n      this.upload()\n    &#125;,\n    upload()&#123;\n       this.$emit(&#39;upload&#39;, this.imageUrl)\n    &#125;\n  &#125;\n\n&lt;!--父组件--&gt;\n&#x2F;&#x2F; 简写形式，适用于传单个参数，不需要在methods中定义函数\n&lt;imgUpload @upload&#x3D;&quot;(url) &#x3D;&gt; &#123;img &#x3D; url&#125;&quot;&gt;&lt;&#x2F;imgUpload&gt;\n&lt;imgUpload @upload&#x3D;&quot;upgood&quot;&gt;&lt;&#x2F;imgUpload&gt;\n\nmethods:&#123;\n  upgood(url)&#123;\n    this.img &#x3D; url\n  &#125;\n&#125;\n\n子传父-多参数&#x2F;&#x2F; 子组件\nupload()&#123;\n  this.$emit(&#39;upload&#39;, this.imageUrl,1,2,3,4,5,6)\n&#125;\n&#x2F;&#x2F; 父组件\nupload(url,...params)&#123;\n  console.log(url,params)\n&#125;\n&#x2F;&#x2F; 输出为 &#39;url&#39; [1,2,3,4,5,6]\n\nref传值&#x2F;&#x2F; 子组件\ndata()&#123;\n  return &#123;\n    name: &#39;Taylor&#39;\n  &#125;\n&#125;,\nmethods:&#123;\n  test()&#123;\n    this.$emit(&#39;test&#39;,this.name)\n  &#125;\n&#125;\n\n&lt;!--父组件--&gt;\n&lt;child ref&#x3D;&quot;tt&quot;&gt;&lt;&#x2F;child&gt;\n\n&#x2F;&#x2F; 推荐写法\nmethods:&#123;\n  getName(name)&#123;\n\t\tconsole.log(name)\n  &#125;\n&#125;,\nmounted()&#123;\n  this.$refs.child.$on(&quot;test&quot;,this.getName)\n&#125;\n&#x2F;&#x2F; 其他写法\nthis.$refs.child.$on(&quot;test&quot;,(name) &#x3D;&gt; &#123;\n  console.log(name)\n&#125;)\n\n组件原生事件&lt;!--组件绑定原生事件需要添加 native 修饰符--&gt;\n&lt;child @click.native&#x3D;&quot;test&quot;&gt;&lt;&#x2F;child&gt;\n\nRouter-link 传值的方法props接受方法同组件传值\n&#x2F;&#x2F; index.js\n&#123;\n  path: &#39;anime&#39;,\n  name: &#39;anime&#39;,\n  component: () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;study&#x2F;anime&#x2F;anime.vue&#39;),\n  &#x2F;&#x2F; props的第一种写法，值为对象，该对象 中所有key-value都会以props的形式传给anime组件\n  props: &#123;a:1,b:&#39;queen&#39;&#125;\n  &#x2F;&#x2F; props的第二种写法，值为布尔值，若为真，就会吧该路由组件收到的所有parmas参数，以props的形式传给anime组件\n  props: true\n  &#x2F;&#x2F; props的第三种写法，值为函数  可以传递query参数和parmas参数\n  props($route)&#123;\n    return &#123;id:$route.query.id,type:$route.query.type&#125;\n  &#125;\n&#125;,\n\nparams传值：\n&lt;router-link\n             :to&#x3D;&quot;&#123;name:&#39;shopnoticeInfo&#39;,params:&#123;id:item.id&#125;&#125;&quot;\n             v-for&#x3D;&quot;(item, index) in msg&quot;\n             :key&#x3D;&quot;index&quot;\n             &gt;\n  &lt;li class&#x3D;&quot;align-center between&quot;&gt;\n    &lt;p v-if&#x3D;&quot;item.title&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;&#x2F;p&gt;\n  &lt;&#x2F;li&gt;\n&lt;&#x2F;router-link&gt;\n\n使用：\n&lt;h1&gt;&#123;&#123;this.$route.params.id&#125;&#125;&lt;&#x2F;h1&gt;\n\nconsole.log(&#39;id&#x3D;&#39;+this.$route.params.id)\n\nquery传值：\n&lt;router-link :to&#x3D;&quot;&#123;path:&#39;&#x2F;shopnoticeInfo&#39;,query:&#123;id:item.id&#125;&#125;&quot; v-for&#x3D;&quot;(item, index) in msg&quot; :key&#x3D;&quot;index&quot;&gt;\n    &lt;li class&#x3D;&quot;align-center between&quot;&gt;\n        &lt;p v-if&#x3D;&quot;item.title&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;li&gt;\n&lt;&#x2F;router-link&gt;\n\n使用：\n&lt;h1&gt;&#123;&#123;this.$route.query.id&#125;&#125;&lt;&#x2F;h1&gt;\n\nconsole.log(&#39;id&#x3D;&#39;+this.$route.query.id)\n\npath/:typeRouter 配置\n&#123;\n    path: &quot;&#x2F;info&#x2F;:type&quot;,\n    name: &quot;info&quot;,\n    component: info\n&#125;\n\n传值：\n&lt;router-link to&#x3D;&quot;&#x2F;info&#x2F;id&quot;&gt;&lt;&#x2F;router-link&gt;&#x2F;&lt;router-link :to&#x3D;&quot;&#39;&#x2F;info&#x2F;&#39;+name&quot;&gt;&lt;&#x2F;router-link&gt;\n&lt;script&gt;\n\texport default &#123;\n      name: &quot;info&quot;,\n      data() &#123;\n          return &#123;\n              name: &#39;taylor&#39;\n          &#125;;\n      &#125;\n  &#125;;\n&lt;&#x2F;script&gt;\n\n使用：\n&lt;h1&gt;&#123;&#123;this.$route.params.type&#125;&#125;&lt;&#x2F;h1&gt;\n\nconsole.log(this.$route.params.type)\n\n总结​    params 参数不会显示在地址栏路径上，但是刷新页面传入的值会失效\n​    query 参数会显示在地址栏上，刷新页面不会消失\njs路由转跳转跳到指定页面\nthis.$router.push(&#123; path: &quot;.&#x2F;publishtask3&quot; &#125;);\n\n返回上一页\nthis.$router.go(-1);\n\n缓存路由组件该组件可以在路由切换时不销毁组件，用于保留用户输入内容\ninclude属性可指定要缓存的组件（组件名），不设置则缓存所有子组件\n&lt;keep-alive include&#x3D;&quot;vue&quot;&gt;\n  &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;keep-alive&gt;\n&lt;!--缓存多个--&gt;\n&lt;keep-alive :include&#x3D;&quot;[&#39;vue&#39;,&#39;anime&#39;]&quot;&gt;\n  &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;keep-alive&gt;\n\n路由守卫&#x2F;&#x2F; 全局前置路由守卫  初始化&amp;每次切换前被调用\nrouter.beforeEach((to, from, next) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; console.log(to, from)\n    &#x2F;&#x2F; console.log(router)\n    if (to.name &#x3D;&#x3D; &#39;vue&#39;) &#123;   &#x2F;&#x2F; name为路由中配置的name\n        if (router.app.$options.store.state.name &#x3D;&#x3D; &#39;raver&#39;) &#123;\n            next()\n        &#125;else&#123;\n            ElementUI.Message(&#39;你没有权限&#39;)\n        &#125;\n    &#125;else&#123;\n        next()\n    &#125;\n\n&#125;)\n&#x2F;*------------------------------------------------------*&#x2F;\n&#x2F;&#x2F; 也可在路由配置中配置meta决定是否校验，适合多组件\n&#123;\n  path: &#39;vue&#39;,\n  name: &#39;vue&#39;,\n  component: () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;study&#x2F;vue&#x2F;index.vue&#39;),\n  meta: &#123;isAuth: true&#125;\n&#125;\n&#x2F;&#x2F; -----\nrouter.beforeEach((to, from, next) &#x3D;&gt; &#123;\n    if (to.meta.isAuth) &#123;   &#x2F;&#x2F; name为路由中配置的meta参数\n        if (router.app.$options.store.state.name &#x3D;&#x3D; &#39;raver&#39;) &#123;\n            next()\n        &#125;else&#123;\n            ElementUI.Message(&#39;你没有权限&#39;)\n        &#125;\n    &#125;else&#123;\n        next()\n    &#125;\n\n&#125;)\n  \n&#x2F;*-----------------------------------------------------------*&#x2F;\n&#x2F;&#x2F; 全局后置守卫路由\n&#x2F;&#x2F; 全局后置路由守卫  初始化&amp;每次切换后被调用\nrouter.afterEach( (to,from) &#x3D;&gt; &#123;\n  \t&#x2F;&#x2F; 可以在meta中配置标签信息，在切换是修改页面标签\n    document.title &#x3D; to.meta.title || &#39;hello-Vue&#39;\n    \n&#125;)\n&#x2F;&#x2F; 独享路由守卫\n&#123;\n  path: &#39;&#x2F;&#39;,\n  name: &#39;study&#39;,\n  component: () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;study&#x2F;index.vue&#39;),\n  meta: &#123;isAuth: false,title:&#39;study&#39;&#125;,\n  beforeEnter: (to, from, next) &#x3D;&gt; &#123;\n    if (router.app.$options.store.state.name &#x3D;&#x3D; &#39;raver&#39;) &#123;\n      next()\n    &#125;else&#123;\n      Message(&#39;你没有权限&#39;)\n    &#125;\n  &#125;\n&#125;,\n\n组件内路由守卫export default &#123;\n  name: &quot;github&quot;,\n  data() &#123;\n    return &#123;&#125;;\n  &#125;,\n  &#x2F;&#x2F; 通过路由规则进入该组件时被调用\n  beforeRouteEnter(to, from, next)&#123;\n    next() \n  &#125;,\n  &#x2F;&#x2F; 通过路由规则离开该组件时被调用\n  beforeRouteLeave(to, from, next) &#123;\n    next()\n  &#125;\n&#125;\n\n\n\n侦听 watch侦听数组增加减少\n&#x2F;&#x2F; 简写形式\nwatch: &#123; \n    value(newvalue,oldvalue) &#123; \n        console.log(this.value) \n    &#125; \n&#125;\n\n深度侦听\n侦听data()&#123;\n  return&#123;\n    name: &#39;Queen&#39;,\n    address: &#39;now&#39;,\n    nums:&#123;\n      a: 1,\n      b: 2,\n    &#125;\n  &#125;\n&#125;,\nwatch: &#123;\n  &#x2F;&#x2F; \t需求：只侦听a不侦听b\n  &#x2F;&#x2F; 写法如下 \n    &#39;nums.a&#39;: &#123;  &#x2F;&#x2F; watch的key实质上是字符串，习惯写法其实是简写形式\n      \timmediate: true,  &#x2F;&#x2F; 初始化时让handler调用一下\n        handler() &#123;\n            console.log(this.value)\n        &#125;,\n        deep: true   \n    &#125;\n&#125;\n\n深度侦听（侦听对象/数组内部参数）\nwatch: &#123;\n  &#x2F;&#x2F; 需求：侦听数组&#x2F;对象下所有变化\n  &#x2F;&#x2F; 方法如下\n    value: &#123;\n        handler() &#123;\n            console.log(this.value)\n        &#125;,\n        deep: true   &#x2F;&#x2F; 开启深度侦听\n    &#125;\n&#125;\n\n方法写在methods中\nwatch:&#123;  \n    value: &#39;test&#39;\n&#125;,\nmethods:&#123;  \n    test()&#123; \n        console.log(this.value)  \n    &#125;\n&#125;\n\n拓展写法\nvar vm &#x3D; new Vue(&#123;\n  el:&quot;#app&quot;,\n  data()&#123;\n    return&#123;\n      name: &#39;Queen&#39;,\n      address: &#39;now&#39;\n    &#125;\n  &#125;,\n  watch:&#123;\n\n  &#125;\n&#125;);\n\nvm.$watch(&quot;name&quot;,&#123;\n  immediate: true,  &#x2F;&#x2F; 初始化时让handler调用一下\n  handler(newvalue,oldvalue) &#123;\n    console.log(this.name)\n    console.log(&#39;新值&#39;,newvalue,&#39;旧值&#39;,oldvalue)\n  &#125;,\n  deep: true   \n&#125;);\nvm.$watch(&quot;address&quot;,function(newvalue,oldvalue)&#123;\n  console.log(&#39;新值&#39;,newvalue,&#39;旧值&#39;,oldvalue)\n&#125;)\n\nkey的原理 ![截屏2021-10-27 上午11.14.08](/Users/raver/hexo/source/_posts/截屏2021-10-27 上午11.14.08.png)![截屏2021-10-27 上午11.22.10](/Users/raver/hexo/source/_posts/截屏2021-10-27 上午11.22.10.png)\n全局事件总线通过全局事件总线可以实现任意组件之间的通信，\n使用方法\n&#x2F;&#x2F; main.js\nnew Vue(&#123;\n  router,\n  render: h &#x3D;&gt; h(App),\n  beforeCreate()&#123;\n    Vue.prototype.$bus &#x3D; this  &#x2F;&#x2F; 安装全局事件总线 (实质上是定义一个公共组件，通过自定义事件来实现通信)\n  &#125;\n&#125;).$mount(&#39;#app&#39;)\n\n&#x2F;&#x2F; 组件a\nmounted () &#123;\n  this.$bus.$on(&#39;checkTodo&#39;,this.checkTodo)\n&#125;,\nbeforeDestroy () &#123;\n  this.$bus.$off(&#39;checkTodo&#39;)  \n&#125;,\nmethods:&#123;\n  checkTodo(id)&#123;\n    this.id &#x3D; id\n  &#125;\n&#125;\n&#x2F;&#x2F; 组件b\nwatch: &#123;\n  checked() &#123;\n    this.$bus.$emit(&#39;checkTodo&#39;,this.data.id)\n  &#125;,\n&#125;,\n\n混入 mixin功能：可以把多个组件公用的配置提取成一个混入对象\n使用方式：\n创建 mixin.js 文件名随意\n&#x2F;&#x2F; 定义混入\nexport const mixin &#x3D; &#123;\n  data()&#123;&#125;,\n  mounted()&#123;&#125;,\n  methods:&#123;\n\t\ttest()&#123;\n      this.$message.success(&quot;test...&quot;)\n    &#125;\n  &#125;\n&#125;\n\n全局使用\n&#x2F;&#x2F; main.js\nimport &#123;mixin&#125; from .&#x2F;mixin.js\nVue.mixin(mixin)\n\n&#x2F;&#x2F; 组件\nmounted()&#123;\n  this.test()\n&#125;,\nmethods:&#123;\n  showMsg()&#123;\n    this.test()\n  &#125;\n&#125;\n\n&lt;!--组件--&gt;\n&lt;button @click&#x3D;&quot;test()&quot;&gt;测试&lt;&#x2F;button&gt;\n\n局部使用 \nimport &#123; mixin &#125; from &quot;.&#x2F;mixin&quot;;\nexport default &#123;\n  name: &quot;ts1&quot;,\n  data() &#123;\n    return &#123;&#125;;\n  &#125;,\n  mixins: [mixin],\n&#125;;\n&#x2F;&#x2F; 使用方法同全局混入\n\nVue 插件在src下创建plugin.js\n&#x2F;&#x2F; main.js\n&#x2F;&#x2F; 引入插件\nimport plugins from &#39;.&#x2F;plugins&#39;\n&#x2F;&#x2F; 使用插件\nVue.use(plugins)\n\n\n&#x2F;&#x2F; plugin.js\nelxport default &#123;\n\tinstall(Vue)&#123;\n    \t\t&#x2F;&#x2F; 定义全局过滤器\n        Vue.filter(&#39;mySlice&#39;, function (val) &#123;\n            return val.slice(0, 4)\n        &#125;)\n        &#x2F;&#x2F; 定义全局指令\n        Vue.directive(&#39;big&#39;, function (element, binding) &#123;\n            element.innerText &#x3D; binding.value * 10\n        &#125;)\n        &#x2F;&#x2F; 定义混入\n        Vue.mixin(&#123;\n            methods: &#123;\n                mixintt() &#123;\n                    this.$message.success(&#39;全局混入&#39;)\n                &#125;\n            &#125;\n        &#125;)\n        &#x2F;&#x2F; 给Vue原型上添加一个方法（vm、vc就都可以调用了）\n        Vue.prototype.$hello &#x3D; () &#x3D;&gt; &#123;\n            console.log(&#39;hello&#39;)\n        &#125;\n  &#125;\n&#125;\n\n插槽插槽内元素与样式既可以写在子组件也可以写在父组件\n\n默认插槽\n\n&lt;!--子组件 tt--&gt;\n&lt;template&gt;\n\t&lt;div&gt;标题&lt;&#x2F;div&gt;\n  &lt;slot&gt;默认值&lt;&#x2F;slot&gt;\n&lt;&#x2F;template&gt;\n&lt;!--父组件--&gt;\n&lt;tt&gt;\n\t&lt;p&gt;测试参数值&lt;&#x2F;p&gt;\n&lt;&#x2F;tt&gt;\n\n\n具名插槽\n\n&lt;!--子组件 tt--&gt;\n&lt;template&gt;\n\t&lt;div&gt;标题&lt;&#x2F;div&gt;\n  &lt;slot name&#x3D;&quot;a&quot;&gt;默认值a&lt;&#x2F;slot&gt;\n  &lt;slot name&#x3D;&quot;b&quot;&gt;默认值b&lt;&#x2F;slot&gt;\n&lt;&#x2F;template&gt;\n&lt;!--父组件--&gt;\n&lt;tt&gt;\n\t&lt;p slot&#x3D;&quot;a&quot;&gt;测试参数值a1&lt;&#x2F;p&gt;\n  &lt;p slot&#x3D;&quot;a&quot;&gt;测试参数值a2&lt;&#x2F;p&gt;\n  &lt;ul slot&#x3D;&quot;a&quot;&gt;\n    &lt;li v-for&#x3D;&quot;item in 3&quot; :key&#x3D;&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;raver&lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n\t&lt;template v-slot:b&gt;\n  \t&lt;p&gt;测试参数值b1&lt;&#x2F;p&gt;\n    &lt;p&gt;测试参数值b2&lt;&#x2F;p&gt;\n    &lt;ul&gt;\n      &lt;li v-for&#x3D;&quot;item in 3&quot; :key&#x3D;&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;raver&lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;template&gt;\n&lt;&#x2F;tt&gt;\n\n\n作用域插槽\n\n&lt;!--子组件--&gt;\n&lt;template&gt;\n\t&lt;div&gt;标题&lt;&#x2F;div&gt;\n  &lt;slot :tt&#x3D;&quot;obj&quot; ts&#x3D;&quot;taylor&quot;&lt;&#x2F;slot&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\n\t\texport default&#123;\n\t\t\tdata()&#123;\n      \treturn&#123;\n\t\t\t\t\tobj:[&#39;taylor&#39;,&#39;raver&#39;,&#39;tim&#39;,&#39;avicii&#39;]\n        &#125;\n    \t&#125;\n    &#125;\n&lt;&#x2F;script&gt;\n\n&lt;!--父组件--&gt;\n&lt;tt&gt;\n\t&lt;template scope&#x3D;&quot;data&quot;&gt;\n    &lt;p&gt;&#123;&#123;data.ts&#125;&#125;&lt;&#x2F;p&gt;\n\t\t&lt;ul&gt;\n       &lt;li v-for&#x3D;&quot;item in data.obj&quot; :key&#x3D;&quot;item&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;template&gt;\n&lt;&#x2F;tt&gt;\n&lt;!--es6--&gt;\n&lt;tt&gt;\n\t&lt;template scope&#x3D;&quot;&#123;obj,ts&#125;&quot;&gt;\n    &lt;p&gt;&#123;&#123;ts&#125;&#125;&lt;&#x2F;p&gt;\n\t\t&lt;ul&gt;\n       &lt;li v-for&#x3D;&quot;item in obj&quot; :key&#x3D;&quot;item&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;template&gt;\n&lt;&#x2F;tt&gt;\n\nVuex\n创建store/index.js\n\n&#x2F;&#x2F; index.js\nimport Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\nVue.use(Vuex)\nconst actions &#x3D; &#123;&#125;\nconst mutations &#x3D; &#123;&#125;\nconst state &#x3D; &#123;\n  \n&#125;\nexport default new Vuex(&#123;\n  actions,\n  mutations,\n  state,\n&#125;)\n\n\n&#x2F;&#x2F; main.js\nimport store from &#39;.&#x2F;store&#39;\n\nnew Vue(&#123;\n  el:&#39;#app&#39;,\n  render: h &#x3D;&gt; h(App),\n  store\n&#125;)\n\n\n\n\n\n","slug":"vue学习笔记","date":"2021-11-07T08:06:12.000Z","categories_index":"","tags_index":"vue","author_index":"Raver233"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"pubsub.js消息订阅插件, 功能与全局事件总线相同\nnpm install pubsub-js\n&#x2F;&#x2F; 在需要使用的组件中引入\nimport pubsub from &#39;pubsub-js&#39;\n&#x2F;&#x2F; 全局引入 main.js\nimport pubsub from &#39;pubsub-js&#39;\nVue.prototype.$pubsub &#x3D; pubsub\n\n&#x2F;&#x2F; 组件a 订阅消息\nmounted()&#123;\n\tthis.pubId &#x3D; pubsub.subscribe(&quot;name&quot;,(msgName,data) &#x3D;&gt; &#123;&#125;)\n&#125;,\nbeforeDestroy()&#123;\n  pubsub.unsubscribe(this.pubId)   &#x2F;&#x2F; 在组件销毁前取消订阅，需要传入订阅id，类似于取消定时器\n&#125;\n\n&#x2F;&#x2F; 组件b 发布消息\nmethods:&#123;\n\ttest()&#123;\n    pubsub.publish(&quot;name&quot;,data)\n  &#125;\n&#125;\n\n\n\n\nanime.jsnpm install animejs\n&#x2F;&#x2F; main.js\nimport anime from &quot;animejs&#x2F;lib&#x2F;anime.es&quot;;\nVue.prototype.$anime &#x3D; anime\n&#x2F;&#x2F; 组件\nthis.$anime(&#123;\n  targets: &quot;#element&quot;,\n  translateY: -200,\n&#125;);\n\nlottiefiles网址\nhttps:&#x2F;&#x2F;lottiefiles.com\n\nnpm install --save @lottiefiles&#x2F;lottie-player\n&#x2F;&#x2F; main.js\nimport &quot;@lottiefiles&#x2F;lottie-player&quot;;\n\n\n&#x2F;&#x2F; 组件\n&lt;lottie-player\n  autoplay\n  controls\n  loop\n  mode&#x3D;&quot;normal&quot;\n  src&#x3D;&quot;https:&#x2F;&#x2F;assets3.lottiefiles.com&#x2F;packages&#x2F;lf20_UJNc2t.json&quot;\n  style&#x3D;&quot;width: 320px&quot;\n&gt;\n&lt;&#x2F;lottie-player&gt;\n\n\nEchartsnpm install echarts --save\n\n&#x2F;&#x2F; main.js\nimport * as echarts from &#39;echarts&#39;;\nVue.prototype.$echarts &#x3D; echarts\n&#x2F;&#x2F; 组件\nsetChart() &#123;\n  var myChart &#x3D; this.$echarts.init(document.getElementById(&quot;chart&quot;));\n  &#x2F;&#x2F; 绘制图表\n  myChart.setOption(&#123;\n    title: &#123;\n      text: &quot;ECharts 入门示例&quot;,\n    &#125;,\n    tooltip: &#123;&#125;,\n    xAxis: &#123;\n      data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;],\n    &#125;,\n    yAxis: &#123;&#125;,\n    series: [\n      &#123;\n        name: &quot;销量&quot;,\n        type: &quot;bar&quot;,\n        data: [5, 20, 36, 10, 10, 20],\n      &#125;,\n    ],\n  &#125;);\n&#125;,\n\nparticles.jsnpm install --save particles.js\n\n&#x2F;&#x2F; main.js\nimport particles from &#39;particles.js&#39;\nVue.use(particles)\n&#x2F;&#x2F; 组件\nwindow.particlesJS(&quot;particles&quot;, this.config);\n\nsassnpm install node-sass@7\nnpm install sass-loader@7\nnpm install sass\n\n","slug":"Vue-cli4","date":"2021-10-30T06:16:51.355Z","categories_index":"","tags_index":"","author_index":"Raver233"},{"id":"7576511c9474b64de0bd6839284801c3","title":"sass","content":"sass –watch scss:css\n","slug":"sass","date":"2021-10-18T00:37:21.000Z","categories_index":"","tags_index":"","author_index":"Raver233"},{"id":"973e5dd0cbccced2b85e4e98cb5c34f7","title":"HTML&CSS","content":"Input自定义样式\n&#x2F;* 自定义input样式 *&#x2F;\ninput::-webkit-input-placeholder &#123;\n  &#x2F;* WebKit browsers *&#x2F;\n  color: #fff;\n  font-size: 18px;\n&#125;\ninput:-moz-placeholder &#123;\n  &#x2F;* Mozilla Firefox 4 to 18 *&#x2F;\n  color: #fff;\n  font-size: 18px;\n&#125;\ninput::-moz-placeholder &#123;\n  &#x2F;* Mozilla Firefox 19+ *&#x2F;\n  color: #fff;\n  font-size: 18px;\n&#125;\ninput:-ms-input-placeholder &#123;\n  &#x2F;* Internet Explorer 10+ *&#x2F;\n  color: #fff;\n  font-size: 18px;\n&#125;\n\n\n\n隐藏切换按钮 type=number\n&#x2F;* 隐藏input（number）上下按钮 *&#x2F;\ninput::-webkit-outer-spin-button,\ninput::-webkit-inner-spin-button &#123;\n  -webkit-appearance: none;\n&#125;\ninput[type&#x3D;&quot;number&quot;] &#123;\n  -moz-appearance: textfield;\n&#125;\n\n","slug":"HTML-CSS","date":"2021-09-25T02:53:05.000Z","categories_index":"","tags_index":"","author_index":"Raver233"},{"id":"5f258f833478a2a0e21ce42d19305683","title":"Vue","content":"Webpack组件传值子传父子组件\n&lt;el-upload\n           name&#x3D;&#39;image&#39;\n           :action&#x3D;&#39;$store.state.host + &quot;&#x2F;business.php&#x2F;Common&#x2F;upload&quot;&#39;\n           :headers &#x3D; token\n           :on-success&#x3D;&quot;handleAvatarSuccess&quot;\n           &gt;\n  &lt;img v-if&#x3D;&quot;imageUrl&quot; :src&#x3D;&quot;imageUrl&quot; class&#x3D;&quot;avatar&quot; &#x2F;&gt;\n  &lt;i v-else class&#x3D;&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;&#x2F;i&gt;\n&lt;&#x2F;el-upload&gt;\n\n\n\nmethods: &#123;\n    handleAvatarSuccess(res, file) &#123;\n      this.imageUrl &#x3D; URL.createObjectURL(file.raw);\n      this.upload()\n    &#125;,\n    upload()&#123;\n       this.$emit(&#39;upload&#39;, this.imageUrl)\n    &#125;\n  &#125;\n\n父组件\nimport imageUpload from &#39;@&#x2F;components&#x2F;ImageUpload&#x2F;index.vue&#39;\n\n&lt;imgUpload @upload&#x3D;&quot;upgood&quot;&gt;&lt;&#x2F;imgUpload&gt;\n\nmethods:&#123;\n  upgood(url)&#123;\n    this.img &#x3D; url\n  &#125;\n&#125;\n\n子传父-多参数\n&#x2F;&#x2F; 子组件\nupload()&#123;\n  this.$emit(&#39;upload&#39;, this.imageUrl,1,2,3,4,5,6)\n&#125;\n&#x2F;&#x2F; 父组件\nupload(url,...params)&#123;\n  console.log(url,params)\n&#125;\n&#x2F;&#x2F; 输出。 &#39;url&#39; [1,2,3,4,5,6]\n\nref传值&#x2F;&#x2F; 子组件\ndata()&#123;\n  return &#123;\n    name: &#39;Taylor&#39;\n  &#125;\n&#125;,\nmethods:&#123;\n  test()&#123;\n    this.$emit(&#39;test&#39;,this.name)\n  &#125;\n&#125;\n\n&lt;!--父组件--&gt;\n&lt;child ref&#x3D;&quot;tt&quot;&gt;&lt;&#x2F;child&gt;\n\n&#x2F;&#x2F; 推荐写法\nmethods:&#123;\n  getName(name)&#123;\n\t\tconsole.log(name)\n  &#125;\n&#125;,\nmounted()&#123;\n  this.$refs.child.$on(&quot;test&quot;,this.getName)\n&#125;\n&#x2F;&#x2F; 其他写法\nthis.$refs.child.$on(&quot;test&quot;,(name) &#x3D;&gt; &#123;\n  console.log(name)\n&#125;)\n\n组件原生事件&lt;!--组件绑定原生事件需要添加 native 修饰符--&gt;\n&lt;child @click.native&#x3D;&quot;test&quot;&gt;&lt;&#x2F;child&gt;\n\n全局事件总线任意组件间通信\nRouter-link 传值的方法props接受方法同组件传值\n&#x2F;&#x2F; index.js\n&#123;\n  path: &#39;anime&#39;,\n  name: &#39;anime&#39;,\n  component: () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;study&#x2F;anime&#x2F;anime.vue&#39;),\n  &#x2F;&#x2F; props的第一种写法，值为对象，该对象 中所有key-value都会以props的形式传给anime组件\n  props: &#123;a:1,b:&#39;queen&#39;&#125;\n  &#x2F;&#x2F; props的第二种写法，值为布尔值，若为真，就会吧该路由组件收到的所有parmas参数，以props的形式传给anime组件\n  props: true\n  &#x2F;&#x2F; props的第三种写法，值为函数  可以传递query参数和parmas参数\n  props($route)&#123;\n    return &#123;id:$route.query.id,type:$route.query.type&#125;\n  &#125;\n&#125;,\n\n\n\nparams传值：\n&lt;router-link\n             :to&#x3D;&quot;&#123;name:&#39;shopnoticeInfo&#39;,params:&#123;id:item.id&#125;&#125;&quot;\n             v-for&#x3D;&quot;(item, index) in msg&quot;\n             :key&#x3D;&quot;index&quot;\n             &gt;\n  &lt;li class&#x3D;&quot;align-center between&quot;&gt;\n    &lt;p v-if&#x3D;&quot;item.title&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;&#x2F;p&gt;\n  &lt;&#x2F;li&gt;\n&lt;&#x2F;router-link&gt;\n\n\n\n使用：\n&lt;h1&gt;&#123;&#123;this.$route.params.id&#125;&#125;&lt;&#x2F;h1&gt;\n\nconsole.log(&#39;id&#x3D;&#39;+this.$route.params.id)\n\nquery传值：\n&lt;router-link :to&#x3D;&quot;&#123;path:&#39;&#x2F;shopnoticeInfo&#39;,query:&#123;id:item.id&#125;&#125;&quot; v-for&#x3D;&quot;(item, index) in msg&quot; :key&#x3D;&quot;index&quot;&gt;\n    &lt;li class&#x3D;&quot;align-center between&quot;&gt;\n        &lt;p v-if&#x3D;&quot;item.title&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;li&gt;\n&lt;&#x2F;router-link&gt;\n\n使用：\n&lt;h1&gt;&#123;&#123;this.$route.query.id&#125;&#125;&lt;&#x2F;h1&gt;\n\nconsole.log(&#39;id&#x3D;&#39;+this.$route.query.id)\n\npath/:typeRouter 配置\n&#123;\n    path: &quot;&#x2F;info&#x2F;:type&quot;,\n    name: &quot;info&quot;,\n    component: info\n&#125;\n\n传值：\n&lt;router-link to&#x3D;&quot;&#x2F;info&#x2F;id&quot;&gt;&lt;&#x2F;router-link&gt;&#x2F;&lt;router-link :to&#x3D;&quot;&#39;&#x2F;info&#x2F;&#39;+name&quot;&gt;&lt;&#x2F;router-link&gt;\n&lt;script&gt;\n\texport default &#123;\n      name: &quot;info&quot;,\n      data() &#123;\n          return &#123;\n              name: &#39;taylor&#39;\n          &#125;;\n      &#125;\n  &#125;;\n&lt;&#x2F;script&gt;\n\n使用：\n&lt;h1&gt;&#123;&#123;this.$route.params.type&#125;&#125;&lt;&#x2F;h1&gt;\n\nconsole.log(this.$route.params.type)\n\n总结​    params 参数不会显示在地址栏路径上，但是刷新页面传入的值会失效\n​    query 参数会显示在地址栏上，刷新页面不会消失\njs路由转跳转跳到指定页面\nthis.$router.push(&#123; path: &quot;.&#x2F;publishtask3&quot; &#125;);\n\n返回上一页\nthis.$router.go(-1);\n\n缓存路由组件该组件可以在路由切换时不销毁组件，用于保留用户输入内容\ninclude属性可指定要缓存的组件（组件名），不设置则缓存所有子组件\n&lt;keep-alive include&#x3D;&quot;vue&quot;&gt;\n  &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;keep-alive&gt;\n&lt;!--缓存多个--&gt;\n&lt;keep-alive :include&#x3D;&quot;[&#39;vue&#39;,&#39;anime&#39;]&quot;&gt;\n  &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;keep-alive&gt;\n\n\n\n侦听 watch侦听数组增加减少\n&#x2F;&#x2F; 简写形式\nwatch: &#123; \n    value(newvalue,oldvalue) &#123; \n        console.log(this.value) \n    &#125; \n&#125;\n\n深度侦听\n侦听data()&#123;\n  return&#123;\n    name: &#39;Queen&#39;,\n    address: &#39;now&#39;,\n    nums:&#123;\n      a: 1,\n      b: 2,\n    &#125;\n  &#125;\n&#125;,\nwatch: &#123;\n  &#x2F;&#x2F; \t需求：只侦听a不侦听b\n  &#x2F;&#x2F; 写法如下 \n    &#39;nums.a&#39;: &#123;  &#x2F;&#x2F; watch的key实质上是字符串，习惯写法其实是简写形式\n      \timmediate: true,  &#x2F;&#x2F; 初始化时让handler调用一下\n        handler() &#123;\n            console.log(this.value)\n        &#125;,\n        deep: true   \n    &#125;\n&#125;\n\n深度侦听（侦听对象/数组内部参数）\nwatch: &#123;\n  &#x2F;&#x2F; 需求：侦听数组&#x2F;对象下所有变化\n  &#x2F;&#x2F; 方法如下\n    value: &#123;\n        handler() &#123;\n            console.log(this.value)\n        &#125;,\n        deep: true   &#x2F;&#x2F; 开启深度侦听\n    &#125;\n&#125;\n\n方法写在methods中\nwatch:&#123;  \n    value: &#39;test&#39;\n&#125;,\nmethods:&#123;  \n    test()&#123; \n        console.log(this.value)  \n    &#125;\n&#125;\n\n拓展写法\nvar vm &#x3D; new Vue(&#123;\n  el:&quot;#app&quot;,\n  data()&#123;\n    return&#123;\n      name: &#39;Queen&#39;,\n      address: &#39;now&#39;\n    &#125;\n  &#125;,\n  watch:&#123;\n\n  &#125;\n&#125;);\n\nvm.$watch(&quot;name&quot;,&#123;\n  immediate: true,  &#x2F;&#x2F; 初始化时让handler调用一下\n  handler(newvalue,oldvalue) &#123;\n    console.log(this.name)\n    console.log(&#39;新值&#39;,newvalue,&#39;旧值&#39;,oldvalue)\n  &#125;,\n  deep: true   \n&#125;);\nvm.$watch(&quot;address&quot;,function(newvalue,oldvalue)&#123;\n  console.log(&#39;新值&#39;,newvalue,&#39;旧值&#39;,oldvalue)\n&#125;)\n\nkey的原理 ![截屏2021-10-27 上午11.14.08](/Users/raver/hexo/source/_posts/截屏2021-10-27 上午11.14.08.png)\n![截屏2021-10-27 上午11.22.10](/Users/raver/hexo/source/_posts/截屏2021-10-27 上午11.22.10.png)\n混入 mixin功能：可以把多个组件公用的配置提取成一个混入对象\n使用方式：\n创建 mixin.js 文件名随意\n&#x2F;&#x2F; 定义混入\nexport const mixin &#x3D; &#123;\n  data()&#123;&#125;,\n  mounted()&#123;&#125;,\n  method:&#123;\n\t\ttest()&#123;\n      this.$message.success(&quot;test...&quot;)\n    &#125;\n  &#125;\n&#125;\n\n全局使用\n&#x2F;&#x2F; main.js\nimport mixin from .&#x2F;mixin.js\nVue.mixin(mixin)\n\n&#x2F;&#x2F; 组件\nmounted()&#123;\n  this.test()\n&#125;,\nmethods:&#123;\n  showMsg()&#123;\n    this.test()\n  &#125;\n&#125;\n\n&lt;!--组件--&gt;\n&lt;button @click&#x3D;&quot;test()&quot;&gt;测试&lt;&#x2F;button&gt;\n\n局部使用 \nimport &#123; test &#125; from &quot;.&#x2F;mixin&quot;;\nexport default &#123;\n  name: &quot;ts1&quot;,\n  data() &#123;\n    return &#123;&#125;;\n  &#125;,\n  mixins: [test],\n&#125;;Ï\n&#x2F;&#x2F; 使用方法同全局混入\n\nVue 插件在src下创建plugin.js\n&#x2F;&#x2F; main.js\n&#x2F;&#x2F; 引入插件\nimport plugins from &#39;.&#x2F;plugins&#39;\n&#x2F;&#x2F; 使用插件\nVue.use(plugins)\n\n\n&#x2F;&#x2F; plugin.js\nelxport default &#123;\n\tinstall(Vue)&#123;\n    &#x2F;&#x2F; 定义全局过滤器\n        Vue.filter(&#39;mySlice&#39;, function (val) &#123;\n            return val.slice(0, 4)\n        &#125;)\n        &#x2F;&#x2F; 定义全局指令\n        Vue.directive(&#39;big&#39;, function (element, binding) &#123;\n            element.innerText &#x3D; binding.value * 10\n        &#125;)\n        &#x2F;&#x2F; 定义混入\n        Vue.mixin(&#123;\n            methods: &#123;\n                mixintt() &#123;\n                    this.$message.success(&#39;全局混入&#39;)\n                &#125;\n            &#125;\n        &#125;)\n        &#x2F;&#x2F; 给Vue原型上添加一个方法（vm、vc就都可以调用了）\n        Vue.prototype.$hello &#x3D; () &#x3D;&gt; &#123;\n            console.log(&#39;hello&#39;)\n        &#125;\n  &#125;\n&#125;\n\n","slug":"Vue","date":"2021-09-13T09:22:00.000Z","categories_index":"","tags_index":"Vue","author_index":"Raver233"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"git init\ngit add .\ngit commit -m&#39;tt&#39;\ngit remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;Taylor5114&#x2F;code.git\ngit push --set-upstream origin master\n\n","slug":"Git","date":"2021-09-07T11:00:50.909Z","categories_index":"","tags_index":"","author_index":"Raver233"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Vue+Element的坑组件回车事件如果是在自己封装的组件或者是使用一些第三方的UI库（比如element-ui）时，会发现并不起效果，这时就需要用到.native修饰符，如：\n&lt;el-input\n  v-model&#x3D;&quot;inputName&quot;\n  placeholder&#x3D;&quot;输入你的名称&quot;\n  @keyup.enter.native&#x3D;&quot;searchPerson&quot;\n  &gt;\n&lt;&#x2F;el-input&gt;\n\n\n\nel-checkbox的渲染axios获取到的data\ndata: [  \n  &#123; id: 1, pid: 1, name: &#39;地区&#39; &#125;,\n  &#123; id: 2, pid: 2, name: &#39;游戏类型&#39; &#125;,\n  &#123; id: 3, pid: 4, name: &#39;性别&#39; &#125;,\n  &#123; id: 4, pid: 5, name: &#39;设备类型&#39; &#125;,\n  &#123; id: 5, pid: 6, name: &#39;休闲时间&#39; &#125;,\n  &#123; id: 6, pid: 7, name: &#39;王者荣耀&#39; &#125;,\n  &#123; id: 7, pid: 8, name: &#39;音乐&#39; &#125;,\n  &#123; id: 8, pid: 9, name: &#39;品牌手表&#39; &#125;,\n  &#123; id: 9, pid: 10, name: &#39;相机&#39; &#125;,\n  &#123; id: 10, pid: 12, name: &#39;游戏人群&#39; &#125;,\n]\n\n前端向data数据中添加checked属性\ndata.forEach(item &#x3D;&gt; &#123;\n  item.checked &#x3D; false\n&#125;)\n\n页面点击多选框还是无法选中，原因是：\n前端添加checked属性，vue并没有添加get set方法，因此监听不到checked值的变化\n解决方法：\n1、使用vue.$set方法，强制监听checked属性\n(res) &#x3D;&gt; &#123;\n  let arr &#x3D; res.data\n  arr.forEach(item &#x3D;&gt; &#123;\n   \tthis.$set(item,&quot;checked&quot;,false)\n  &#125;)\n&#125;\n\n\n\n默认样式修改\n新建全局样式并引入\n\n按需修改样式\n以el-input为例\n.el-input input&#123;\n  border-radius: none;\n  background: pink;\n&#125;\n\n地区选择器 element-china-area-datanpm install element-china-area-data -S\n\n在使用页面script标签中引入\nimport &#123; regionData, CodeToText &#125; from &quot;element-china-area-data&quot;;\n\n代码\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;div&gt;\n      &lt;el-cascader\n        size&#x3D;&quot;large&quot;\n        :options&#x3D;&quot;options&quot;\n        v-model&#x3D;&quot;selectedOptions&quot;\n        @change&#x3D;&quot;handleChange&quot;\n      &gt;\n      &lt;&#x2F;el-cascader&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; regionData, CodeToText &#125; from &quot;element-china-area-data&quot;;\n\nexport default &#123;\n  name: &quot;app&quot;,\n  data() &#123;\n    return &#123;\n      options: regionData,\n      selectedOptions: []\n    &#125;;\n  &#125;,\n\n  methods: &#123;\n    handleChange() &#123;\n      var loc &#x3D; &quot;&quot;;\n      for (let i &#x3D; 0; i &lt; this.selectedOptions.length; i++) &#123;\n        loc +&#x3D; CodeToText[this.selectedOptions[i]];\n      &#125;\n      alert(loc);\n    &#125;\n  &#125;\n&#125;;\n&lt;&#x2F;script&gt;\n\n\n\n","slug":"Element-UI","date":"2021-09-07T09:02:52.644Z","categories_index":"","tags_index":"","author_index":"Raver233"},{"id":"d46fcc29b0dde28b8d1c4f47c372964e","title":"無限進步","content":"無限進步","slug":"無限進步","date":"2021-09-03T15:51:17.000Z","categories_index":"","tags_index":"","author_index":"Raver233"},{"id":"456940ed00435558e02022c8f14ccbe7","title":"js常用方法","content":"js跳转idlocation.hash&#x3D;&quot;#id&quot;\n\n延时setTimeout(()&#x3D;&gt;&#123;\n  location.href &#x3D; &quot;&#x2F;&quot;\n&#125;,1000)\n\n提取富文本文字getText(str) &#123;\n  return str\n    .replace(&#x2F;&lt;[^&lt;&gt;]+&gt;&#x2F;g, &quot;&quot;)\n    .replace(&#x2F;&amp;nbsp;&#x2F;gi, &quot;&quot;);\n&#125;,\n\n循环截取文本setcontent(arr,num) &#123;\n  for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    if (arr[i].name.length &gt; num) &#123;\n      arr[i].name &#x3D; arr[i].name.slice(0, num) + &#39;...&#39;\n    &#125;\n  &#125;\n&#125;,\n\njs拉起本地qq对话框不支持mac\n&#x2F;&#x2F; 移动端\nmqqwpa:&#x2F;&#x2F;im&#x2F;chat?chat_type&#x3D;wpa&amp;uin&#x3D;QQ号&amp;version&#x3D;1&amp;src_type&#x3D;web&amp;web_src&#x3D;http::&#x2F;&#x2F;wpa.b.qq.com\n&#x2F;&#x2F; pc端\nhttp:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;QQ号&amp;site&#x3D;在线客服&amp;menu&#x3D;yes\n\n在线聊天(需要目标账号开启在线聊天功能)\n1、在QQ推广页面上先设置该QQ：http:&#x2F;&#x2F;shang.qq.com&#x2F;v3&#x2F;widget.html\n2、页面上粘贴代码\n&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;1751022481&amp;site&#x3D;qq&amp;menu&#x3D;yes&quot;&gt;&lt;img border&#x3D;&quot;0&quot; src&#x3D;&quot;http:&#x2F;&#x2F;wpa.qq.com&#x2F;pa?p&#x3D;2:1751022481:52&quot; alt&#x3D;&quot;点击这里给我发消息&quot; title&#x3D;&quot;点击这里给我发消息&quot;&#x2F;&gt;&lt;&#x2F;a&gt;\n\n时间戳转换timestampToTime(timestamp) &#123;\n      if (timestamp.toString().length &#x3D;&#x3D; 10) &#123;\n        var date &#x3D; new Date(timestamp * 1000); &#x2F;&#x2F;时间戳为10位需*1000，时间戳为13位的话不需乘1000\n      &#125; else &#123;\n        var date &#x3D; new Date(timestamp);\n      &#125;\n      var Y &#x3D; date.getFullYear() + &quot;-&quot;;\n      var M &#x3D;\n        (date.getMonth() + 1 &lt; 10\n          ? &quot;0&quot; + (date.getMonth() + 1)\n          : date.getMonth() + 1) + &quot;-&quot;;\n      var D &#x3D; date.getDate() &gt; 9 ? date.getDate() + &quot; &quot; : &quot;0&quot; + date.getDate() + &quot; &quot;;\n      var h &#x3D;\n        date.getHours() &gt; 9\n          ? date.getHours() + &quot;:&quot;\n          : &quot;0&quot; + date.getHours() + &quot;:&quot;;\n      var m &#x3D;\n        date.getMinutes() &gt; 9\n          ? date.getMinutes() + &quot;:&quot;\n          : &quot;0&quot; + date.getMinutes() + &quot;:&quot;;\n      var s &#x3D;\n        date.getSeconds() &gt; 9 ? date.getSeconds() : &quot;0&quot; + date.getSeconds();\n  \t\tif (Y + M + D + h + m + s &#x3D;&#x3D; &quot;1970-01-01 08:00:00&quot;) &#123;\n        return &quot;-&quot;;\n      &#125;\n      return Y + M + D + h + m + s;\n    &#125;,\n\n时间转换为多久前getDateDiff(dateTimeStamp) &#123;\n    &#x2F;&#x2F; 时间字符串转时间戳\n    var timestamp &#x3D; new Date(dateTimeStamp).getTime();\n    \n    var minute &#x3D; 1000 * 60;\n    var hour &#x3D; minute * 60;\n    var day &#x3D; hour * 24;\n    var halfamonth &#x3D; day * 15;\n    var month &#x3D; day * 30;\n    var year &#x3D; day * 365;\n    var now &#x3D; new Date().getTime();\n    var diffValue &#x3D; now - timestamp;\n    var result;\n    if (diffValue &lt; 0) &#123;\n        return;\n    &#125;\n    var yearC &#x3D; diffValue &#x2F; year;\n    var monthC &#x3D; diffValue &#x2F; month;\n    var weekC &#x3D; diffValue &#x2F; (7 * day);\n    var dayC &#x3D; diffValue &#x2F; day;\n    var hourC &#x3D; diffValue &#x2F; hour;\n    var minC &#x3D; diffValue &#x2F; minute;\n    if (yearC &gt;&#x3D; 1) &#123;\n        result &#x3D; &quot;&quot; + parseInt(yearC) + &quot;年前&quot;;\n    &#125; else if (monthC &gt;&#x3D; 1) &#123;\n        result &#x3D; &quot;&quot; + parseInt(monthC) + &quot;月前&quot;;\n    &#125; else if (weekC &gt;&#x3D; 1) &#123;\n        result &#x3D; &quot;&quot; + parseInt(weekC) + &quot;周前&quot;;\n    &#125; else if (dayC &gt;&#x3D; 1) &#123;\n        result &#x3D; &quot;&quot; + parseInt(dayC) + &quot;天前&quot;;\n    &#125; else if (hourC &gt;&#x3D; 1) &#123;\n        result &#x3D; &quot;&quot; + parseInt(hourC) + &quot;小时前&quot;;\n    &#125; else if (minC &gt;&#x3D; 1) &#123;\n        result &#x3D; &quot;&quot; + parseInt(minC) + &quot;分钟前&quot;;\n    &#125; else\n        result &#x3D; &quot;刚刚&quot;;\n    return result;\n&#125;,\n\n时间与时间戳相互转换&#x2F;&#x2F; 一：时间转时间戳：javascript获得时间戳的方法有五种，都是通过实例化时间对象 new Date() 来进一步获取当前的时间戳\nvar timestamp1 &#x3D; Date.parse(new Date()); &#x2F;&#x2F; 结果：1477808630000 不推荐这种办法，毫秒级别的数值被转化为000\n\n  console.log(timestamp1);\n\nvar timestamp2 &#x3D; (new Date()).valueOf(); &#x2F;&#x2F; 结果：1477808630404 通过valueOf()函数返回指定对象的原始值获得准确的时间戳值\n\nconsole.log(timestamp2);\n\nvar timestamp3 &#x3D; new Date().getTime(); &#x2F;&#x2F; 结果：1477808630404 ，通过原型方法直接获得当前时间的毫秒值，准确\n\nconsole.log(timestamp3);\n\nvar timetamp4 &#x3D; Number(new Date()) ; &#x2F;&#x2F;结果：1477808630404 ,将时间转化为一个number类型的数值，即时间戳\n\nconsole.log(timetamp4);\n\nES5给Date提供了一种获取时间戳的新特性  \nvar timetamp5 &#x3D; Date.now();                   &#x2F;&#x2F;结果：1477808630404 \n\nconsole.log(timetamp5);\n\n&#x2F;&#x2F; 二，时间戳转时间\nvar timestamp4 &#x3D; new Date(1472048779952);&#x2F;&#x2F;直接用 new Date(时间戳) 格式转化获得当前时间\n\nconsole.log(timestamp4);\n\nconsole.log(timestamp4.toLocaleDateString().replace(&#x2F;\\&#x2F;&#x2F;g, &quot;-&quot;) + &quot; &quot; + timestamp4.toTimeString().substr(0, 8)); &#x2F;&#x2F;再利用拼接正则等手段转化为yyyy-MM-dd hh:mm:ss 格式\n&#x2F;*不过这样转换在某些浏览器上会出现不理想的效果，因为toLocaleDateString()方法是因浏览器而异的，比如 IE为2016年8月24日 22:26:19 格式 搜狗为Wednesday, August 24, 2016 22:39:42\n可以通过分别获取时间的年月日进行拼接，比如：*&#x2F;\nfunction getdate() &#123;\n            var now &#x3D; new Date(),\n                y &#x3D; now.getFullYear(),\n                m &#x3D; (&quot;0&quot; + (now.getMonth() + 1)).slice(-2),\n                d &#x3D; (&quot;0&quot; + now.getDate()).slice(-2);\n            return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;now.toTimeString().substr(0, 8)&#125;&#96;; \n&#125;\n\n对象转数组直接转换\nvar arr &#x3D; []\nfor (let i in obj) &#123;\n    let o &#x3D; &#123;&#125;;\n    o[i] &#x3D; obj[i]; &#x2F;&#x2F;即添加了key值也赋了value值 o[i] 相当于o.name 此时i为变量\n    arr.push(o)\n&#125;\n\n拆分属性名、属性值组成数组\nconst obj &#x3D; &#123;\n            id:1,\n            name:&#39;zhangsan&#39;,\n            age:18\n    &#125;\nconst arr &#x3D; [];\n    Object.getOwnPropertyNames(obj).forEach(function(key)&#123;\n         \n        var o &#x3D; &#123;&#125;;\no.code &#x3D; key;o.value&#x3D;obj[key];arr.push(o);\n    &#125;)\n\n简单函数封装\ntoarr(obj) &#123;\n  var arr &#x3D; [];\n  Object.getOwnPropertyNames(obj).forEach(function (key) &#123;\n    var o &#x3D; &#123;&#125;;\n    o.code &#x3D; key;\n    o.value &#x3D; obj[key];\n    if (o.code !&#x3D; &quot;__ob__&quot;) &#123;\n      arr.push(o);\n    &#125;\n  &#125;);\n  return arr;\n&#125;\n\n\n\n数组格式字符串转数组eval()函数var str &#x3D; &#39;[&quot;山西&quot;,&quot;新疆&quot;,&quot;甘肃&quot;,&quot;宁夏&quot;,&quot;青海&quot;]&#39;;\nvar arr &#x3D; eval(&#39;(&#39;+str+&#39;)&#39;);\n\nconsole.log(arr)\n&#x2F;&#x2F; [&quot;山西&quot;,&quot;新疆&quot;,&quot;甘肃&quot;,&quot;宁夏&quot;,&quot;青海&quot;]\n\n\n\n截取字符串&#x2F;&#x2F; 截取字符串最后一个‘&#x2F;’后的所有内容\nitem.file.substr(item.file.lastIndexOf(&quot;&#x2F;&quot;) +1)\n&#x2F;&#x2F; 截取字符串最后一个‘&#x2F;’后的三个字符\nitem.file.substr(item.file.lastIndexOf(&quot;&#x2F;&quot;) +1，3)\n\n\n\n获取实时时间setTime() &#123;\n  this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;\n    this.time &#x3D;\n      new Date().getFullYear() +\n      &quot;-&quot; +\n      (new Date().getMonth() + 1) +\n      &quot;-&quot; +\n      new Date().getDate() +\n      &quot; &quot; +\n      new Date().getHours() +\n      &quot;:&quot; +\n      new Date().getMinutes() +\n      &quot;: &quot; +\n      new Date().getSeconds();\n  &#125;, 1000);\n&#125;,\n\n对象复制注意：在vue生命周期中调用时 ➕ this\ndeepClone(source) &#123;\n  &#x2F;&#x2F; 判断复制的目标是数组还是对象\n  const targetObj &#x3D; source.constructor &#x3D;&#x3D;&#x3D; Array ? [] : &#123;&#125;;\n  for (const keys in source) &#123;\n    if (source.hasOwnProperty(keys)) &#123;\n      if (source[keys] &amp;&amp; typeof source[keys] &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;\n        &#x2F;&#x2F; 如果值是对象，就递归一下\n        targetObj[keys] &#x3D; source[keys].constructor &#x3D;&#x3D;&#x3D; Array ? [] : &#123;&#125;;\n        targetObj[keys] &#x3D; deepClone(source[keys]);\n      &#125; else &#123;\n        &#x2F;&#x2F; 如果不是，就直接赋值\n        targetObj[keys] &#x3D; source[keys];\n      &#125;\n    &#125;\n  &#125;\n  return targetObj;\n&#125;,\n\n合并两个对象中相同key的值data() &#123;\n  return &#123;\n    info: &#123;\n      name_cn: &quot;&quot;,\n      name_en: &quot;&quot;,\n      post_addr: &quot;&quot;,\n      man1_name: &quot;&quot;,\n      man1_phone: &quot;&quot;,\n      man1_tel: &quot;&quot;,\n      man1_email: &quot;&quot;,\n      man2_name: &quot;&quot;,\n      man2_phone: &quot;&quot;,\n      man2_tel: &quot;&quot;,\n      man2_email: &quot;&quot;,\n    &#125;,\n  &#125;;\n&#125;,\n  created() &#123;\n    if (this.$route.query.type &#x3D;&#x3D; 1) &#123;\n      this.$api.workProdetails(&#123; id: this.$route.query.id &#125;).then((res) &#x3D;&gt; &#123;\n        Object.keys(this.info).forEach((key) &#x3D;&gt; &#123;\n          if(res.data[key]!&#x3D;&#x3D;undefined)this.info[key] &#x3D; res.data[key];\n        &#125;);\n      &#125;);\n    &#125;\n  &#125;,\n\n数组去重 Array.prototype.distinct &#x3D; function () &#123;\n   var arr &#x3D; this,\n       i,\n       j,\n       len &#x3D; arr.length;\n   for (i &#x3D; 0; i &lt; len; i++) &#123;\n     for (j &#x3D; i + 1; j &lt; len; j++) &#123;\n       if (arr[i].id &#x3D;&#x3D; arr[j].id) &#123;\n         arr.splice(j, 1);\n         len--;\n         j--;\n       &#125;\n     &#125;\n   &#125;\n   return arr;\n &#125;;\n&#x2F;&#x2F; 用法\ndata &#x3D; data.distinct()\n\n\n\n","slug":"js常用方法","date":"2021-08-29T14:18:53.000Z","categories_index":"","tags_index":"","author_index":"Raver233"},{"id":"17520cb522f1660fc075da0158dd8615","title":"vuecli","content":"Vue-cli创建新项目&#x2F;&#x2F; tt\ncd path\n&#x2F;&#x2F; \nvue init webpack name\ncd name\n&#x2F;&#x2F; 安装依赖\ncnpm install\n\n\n\nelement-ui安装cnpm i element-ui -S\n\n配置全部引入&#x2F;&#x2F; main.js\nimport ElementUI from &#39;element-ui&#39;\nimport &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;\n\nVue.use(ElementUI)\n\n按需引入&#x2F;&#x2F; 待续\n\naxios安装cnpm install axios\n\n配置main.js\nimport axios from &#39;axios&#39;\n\nVue.prototype.$axios&#x3D;axios\n\n&#x2F;&#x2F; 拦截器\n\t&#x2F;&#x2F; 添加请求拦截器\naxios.interceptors.request.use(function (config) &#123;\n    &#x2F;&#x2F; 在发送请求之前做些什么\n    return config;\n  &#125;, function (error) &#123;\n    &#x2F;&#x2F; 对请求错误做些什么\n    return Promise.reject(error);\n  &#125;);\n\n\t&#x2F;&#x2F; 添加响应拦截器\naxios.interceptors.response.use(function (res) &#123;\n    &#x2F;&#x2F; 对响应数据做点什么\n    return res;\n  &#125;, function (error) &#123;\n    &#x2F;&#x2F; 对响应错误做点什么\n    return Promise.reject(error);\n  &#125;);\n\n使用方法this.$axios(&#123;\n        method: &quot;get&quot;,\n        url: &quot;https:&#x2F;&#x2F;mock.mengxuegu.com&#x2F;mock&#x2F;6103be1af1fafb4ac8285843&#x2F;waterfall&#x2F;waterfall&quot;,\n        data: &#123;&#125;,\n      &#125;).then((res) &#x3D;&gt; &#123;\n        console.log(res);\n      &#125;);\n\nvuex安装cnpm install vuex --save\n\n配置&#x2F;&#x2F; main.js\nimport Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\nimport store from &#39;.&#x2F;store&#x2F;index.js&#39;\n\nVue.use(Vuex)\n\nPromisevuex依赖Promise\ncnpm install es6-promise --save \n\n创建store在src文件夹下创建store文件夹，并在store中新建index.js state.js getters.js mutations.js actions.js\nindex.jsimport Vue from &#39;vue&#39;;\nimport Vuex from &#39;vuex&#39;;\nimport state from &#39;.&#x2F;state.js&#39;;\nimport getters from &#39;.&#x2F;getters.js&#39;;\nimport mutations from &#39;.&#x2F;mutations.js&#39;;\nimport actions from &#39;.&#x2F;actions.js&#39;;\n\nVue.use(Vuex);\nconst store &#x3D; new Vuex.Store(&#123;\n    state,\n    getters,\n    actions,\n    mutations\n&#125;)\n\nexport default store;\n\nstate.jsconst state &#x3D; &#123; &#x2F;&#x2F;存放状态\n    nickname: &#39;Simba&#39;,\n    age: 20,\n    gender: &#39;男&#39;,\n    value: &#39;無限進步&#39;\n&#125;\nexport default state\n\ngetter.js&#96;&#96;&#96;\n\n##### mutations.js\n\n&#96;&#96;&#96;javascript\nconst mutations &#x3D; &#123;\n    addAge(state, payload) &#123;\n        state.age +&#x3D; payload.num\n    &#125;,\n    test() &#123;\n        console.log(&#39;测试...&#39;)\n    &#125;\n&#125;\nexport default mutations\n\nactions.js&#96;&#96;&#96;\n\n### 使用\n\n&#96;&#96;&#96;javascript\n&#x2F;&#x2F; 直接调用\n$store.state.age\nthis.$store.commit(&quot;addAge&quot;, &#123; num: 10 &#125;);\n\n&#x2F;&#x2F; 引入map\nimport &#123; mapMutations, mapState, mapActions &#125; from &quot;vuex&quot;;\nexport default &#123;\n  data() &#123;\n    return &#123;&#125;;\n  &#125;,\n  computed: &#123;\n    value() &#123;\n      return this.$store.state.value;\n    &#125;,\n    ...mapState([&quot;nickname&quot;, &quot;age&quot;, &quot;gender&quot;]),\n    &#x2F;&#x2F; ...mapActions([&quot;act&quot;]),\n    &#x2F;&#x2F; ...mapMutations([&quot;test&quot;]),\n\n\n  &#125;,\n  methods: &#123;\n    tt() &#123;\n      this.$store.commit(&quot;addAge&quot;, &#123; num: 10 &#125;);\n    &#125;,\n  &#125;,\n&#125;;\n\nVue-mate安装npm install vue-meta --save\n\n配置&#x2F;&#x2F; main.js\nimport Meta from &#39;vue-meta&#39;\n\nVue.use(Meta)\n\n&#x2F;&#x2F; 页面\nexport default &#123;\n    name: &#39;Raver233&#39;,\n    metaInfo: &#123;\n      title: &#39;無限進步&#39;,\n      meta: [\n        &#123; charset: &#39;utf-8&#39; &#125;,\n        &#123; name: &#39;viewport&#39;, content: &#39;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,maximum-scale&#x3D;1,user-scalable&#x3D;no&#39; &#125;\n      ]\n    &#125;\n\nheadicon将icon放在static文件夹下在index.html直接引入即可\n引入全局样式在src/assets下创建文件 style.css\nmain.js\nimport &quot;.&#x2F;assets&#x2F;style.css&quot;\n\n\n\nMain.js在main.js中使用element组件ElementUI.Message.error(&quot;请先进行登录&quot;);\n\n在main.js中使用routerrouter.push(&#123; path: &quot;&#x2F;&quot; &#125;);\n\n\n\n\n\n","slug":"vuecli","date":"2021-08-29T13:43:46.000Z","categories_index":"","tags_index":"笔记","author_index":"Raver233"},{"id":"74b72fe7b2c2c19bb01daa5aacb0cb96","title":"Maekdown入门（Typora）","content":"代码块：&#x2F;&#x2F; 代码块语法：\n​&#96;&#96;&#96;java\n  \n\nhtml\n\njavascript\n\n标题&#x2F;&#x2F; 标题语法\n  # 一级标题\n  ## 二级标题  \n  ### 三级标题  \n  #### 四级标题  \n  ##### 五级标题  \n  ###### 六级标题  \n\n字体&#x2F;&#x2F; 加粗\n\t**Taylor Swift**\n&#x2F;&#x2F; 代码高亮显示 Hexo不支持\n\t&#x3D;&#x3D;Taylor Swift&#x3D;&#x3D;\n&#x2F;&#x2F; 删除线\n  ~~Taylor Swift~~\n&#x2F;&#x2F; 斜体\n  *Taylor Swift*\n\n正常显示  加粗显示  ==高亮显示==  删除线  斜体\n引用&#x2F;&#x2F; 引用语法\n  &gt;作者：海子\n  &gt;&gt;作者：海子\n  &gt;&gt;&gt;作者：海子\n\n\n\n\n\n\n\n\n\n\n作者：海子\n\n作者：海子\n\n作者：海子\n\n\n分割线&#x2F;&#x2F; 分割线0\n\t---\n&#x2F;&#x2F; 分割线1\n\t***\n\n\n\n图片插入&#x2F;&#x2F; 在线图片&#x2F;本地图片\n\t![我的图片](&#x2F;image&#x2F;mine.png)\n\n\n\n超链接&#x2F;&#x2F; 超链接语法\n\t[Raver233](https:&#x2F;&#x2F;www.raver233.top)\n\nRaver233\n列表&#x2F;&#x2F; 无序列表\n\t- item0\n\t- item1\n  - item2\n&#x2F;&#x2F; 有序列表\n  1.item0\n  2.item1\n  3.item2\n\n\nitem0\nitem1\nItem2\n\n\nitem0\n\nitem1\n\nitem2\n\n\n表格&#x2F;&#x2F; 表格语法\n\t| Name | Gender | Age  |\n\n\n\n\n\n\nName\nGender\nAge\n\n\n\nRaver\nmale\n20\n\n\n思维导图graph TD;\n\n A--&gt;B;\n\n A--&gt;C; \n\nB--&gt;D;\n\n C--&gt;D;\n\n\nHexo 不支持\n","slug":"Maekdown入门（Typora）","date":"2021-05-11T11:01:00.000Z","categories_index":"","tags_index":"笔记","author_index":"Raver233"}]