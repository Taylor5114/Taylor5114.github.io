{"title":"Vue3","uid":"3a4eda1192ec992162144e15ab7e2ec5","slug":"Vue3","date":"2021-11-21T08:29:09.000Z","updated":"2022-04-14T14:43:34.667Z","comments":true,"path":"api/articles/Vue3.json","keywords":"無限進步","cover":[],"content":"<h1 id=\"常用的Compositon-API\"><a href=\"#常用的Compositon-API\" class=\"headerlink\" title=\"常用的Compositon API\"></a>常用的Compositon API</h1><h2 id=\"setup函数\"><a href=\"#setup函数\" class=\"headerlink\" title=\"setup函数\"></a>setup函数</h2><ul>\n<li><p>理解：vue3.0中一个新的配置项，值为一个函数</p>\n</li>\n<li><p>setup执行的时机</p>\n<ul>\n<li>在beforeCreate之前执行一次，this是undefined</li>\n</ul>\n</li>\n<li><p>setup的参数</p>\n<ul>\n<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性</li>\n<li>content：上下文对象<ul>\n<li>attrs：值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性，相当于 <strong>this.$attrs</strong></li>\n<li>slots：收到的插槽内容，相当于 <strong>this.$slots</strong></li>\n<li>emit：分发自定义事件的函数，相当于 <strong>this.$emit</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>setup是所有Composition API（组合式API）的容器</p>\n</li>\n<li><p>组件中所用到的：数据、方法等等，均要配置在setup中</p>\n</li>\n<li><p>setup函数的两种返回值：</p>\n<ul>\n<li>若返回一个对象，则对象中的属性、方法，在模板中均可以直接使用。（重点！）</li>\n<li>若返回一个渲染函数：则可以自定义渲染内容（了解）</li>\n</ul>\n</li>\n<li><p>注意点：</p>\n<ul>\n<li>尽量不要与Vue2.x配置混用<ul>\n<li>Vue2.x配置（data、methods、computed…）中可以访问到setup中的属性、方法</li>\n<li>但在setup中不能访问到Vue2.x配置（data、methods…)</li>\n<li>如果有重名 setup优先</li>\n</ul>\n</li>\n<li>setup不能是一个async函数，因为返回值不再是return的对象，而是promise，模板看不到return对象中的属性（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"ref函数\"><a href=\"#ref函数\" class=\"headerlink\" title=\"ref函数\"></a>ref函数</h2><ul>\n<li><p>作用：定义一个响应式数据</p>\n</li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const xxx &#x3D; ref(initValue)</code></pre>\n\n<ul>\n<li>创建一个包含响应式数据的应用对象（reference对象）</li>\n<li>JS中操作数据：</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">xxx.value</code></pre>\n\n<ul>\n<li>模板中读取数据：不需要value，直接：</li>\n</ul>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;p&gt;&#123;&#123;xxx&#125;&#125;&lt;&#x2F;p&gt;</code></pre></li>\n<li><p>备注：</p>\n<ul>\n<li>接收的数据可以是：基本类型、也可以是对象类型</li>\n<li>基本类型的数据：响应式依靠的是 <strong>Object.definePropetry()</strong> 的 <strong>get</strong> 与 <strong>set</strong> 完成的</li>\n<li>对象类型的数据：内部“<strong>求助</strong>”了Vue3.0中的一个新函数——<strong>reactive</strong>函数</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"reactive函数\"><a href=\"#reactive函数\" class=\"headerlink\" title=\"reactive函数\"></a>reactive函数</h2><ul>\n<li><p>作用：定义一个<strong>对象类型</strong>的响应式数据（不能用来定义基本类型）</p>\n</li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const 代理对象 &#x3D; reactive(源对象)</code></pre>\n\n<p>接收一个对象（或数组），返回一个<strong>代理对象（proxy对象）</strong></p>\n</li>\n<li><p>reactive定义的响应式数据是“深层次的”</p>\n</li>\n<li><p>内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据进行操作</p>\n</li>\n</ul>\n<h2 id=\"Vue3-0中的响应式原理\"><a href=\"#Vue3-0中的响应式原理\" class=\"headerlink\" title=\"Vue3.0中的响应式原理\"></a>Vue3.0中的响应式原理</h2><h3 id=\"vue2-x的响应式\"><a href=\"#vue2-x的响应式\" class=\"headerlink\" title=\"vue2.x的响应式\"></a>vue2.x的响应式</h3><ul>\n<li><p>实现原理：</p>\n<ul>\n<li><p>对象类型：通过 <strong>Object.defineProperty()</strong> 对属性的读取、修改进行拦截（数据劫持）</p>\n</li>\n<li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Object.defineProperty(data,&#39;count&#39;,&#123;\n  get () &#123;&#125;,\n  set () &#123;&#125;\n&#125;)</code></pre></li>\n</ul>\n</li>\n<li><p>存在问题：</p>\n<ul>\n<li>新增属性、删除属性，界面不会更新</li>\n<li>直接通过下标修改数组，界面不会更新</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vue3-0的响应式\"><a href=\"#vue3-0的响应式\" class=\"headerlink\" title=\"vue3.0的响应式\"></a>vue3.0的响应式</h3><ul>\n<li>实现原理：<ul>\n<li>通过proxy（代理）：拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等</li>\n<li>通过Reflect（反射）：对被代理对象的属性进行操作</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"watchEffect函数\"><a href=\"#watchEffect函数\" class=\"headerlink\" title=\"watchEffect函数\"></a>watchEffect函数</h3><ul>\n<li>watch的套路是：既要指明监视的属性，也要指明监视的回调</li>\n<li>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，就监视哪个属性</li>\n<li>watchEffect有点像computed：<ul>\n<li>但conputed注重的是计算出来的值（回调函数的返回值），所以必须要写返回值</li>\n<li>而watchEffect跟注重的是过程（回调函数的函数体），所以不用写返回值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"自定义hook函数\"><a href=\"#自定义hook函数\" class=\"headerlink\" title=\"自定义hook函数\"></a>自定义hook函数</h3><ul>\n<li>本质是一个函数，把setup函数中使用的Composition API进行封装</li>\n<li>类似于vue2中的mixin</li>\n<li>自定义hook的优势：复用代码，让setup中的逻辑更清楚易懂</li>\n</ul>\n<h3 id=\"toRef\"><a href=\"#toRef\" class=\"headerlink\" title=\"toRef\"></a>toRef</h3><ul>\n<li><p>作用：创建一个ref对象，其value值指向另一个对象中的某个属性</p>\n</li>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const name &#x3D; toRef(person,&#39;name&#39;)\nconst salary &#x3D; toRef(person.job.j1,&#39;salary&#39;)</code></pre></li>\n<li><p>应用：要将响应式独享中的某个属性单独提供给外部使用时</p>\n</li>\n<li><p>扩展：toRefs与toRef功能一致，但可以批量创建多个ref对象</p>\n<ul>\n<li><p>语法：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">return &#123;\n  ...toRefs(person)\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"其他-Composition-API\"><a href=\"#其他-Composition-API\" class=\"headerlink\" title=\"其他 Composition API\"></a>其他 Composition API</h3><ul>\n<li><p>shallowReactive与shallowRef（用于性能优化）</p>\n<ul>\n<li>shallowReactive：只处理对象最外层属性的响应式（浅响应式）</li>\n<li>shallowRef：只处理基本数据类型的响应式，不进行对象的响应式处理</li>\n<li>使用：<ul>\n<li>如果有一个对象数据，结构比较深，但变化时只是外层属性变化===&gt; shallowReactive</li>\n<li>如果有一个数据对象，后续功能不会修改该对象中的属性，而是生成新的对象来替换===&gt; shallowRef</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>readonly与shallowReadonly</p>\n<ul>\n<li>readonly：让一个响应式数据变为只读的（深只读）</li>\n<li>shallowReadonly：让一个响应式数据变为只读的（浅只读：深层次的数据仍可修改）</li>\n<li>应用场景，不希望数据被修改时</li>\n</ul>\n</li>\n<li><p>toRaw与markRaw</p>\n<ul>\n<li>toRaw<ul>\n<li>作用：将一个由 <strong>reactive</strong> 生成的响应式对象转为普通对象</li>\n<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新</li>\n</ul>\n</li>\n<li>markRaw<ul>\n<li>作用：标记一个对象，使其永远不会成为响应式对象</li>\n<li>应用场景<ol>\n<li>有些值不应被设置为响应式的，例如复杂的第三方类库等</li>\n<li>但渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能</li>\n<li>axios</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>customRef</p>\n<ul>\n<li><p>作用：创建一个自定义的ref，并对其依赖项跟踪和更新出发进行显式控制</p>\n</li>\n<li><p>实现防抖效果：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;   自定义一个ref 实现防抖功能\n    function myRef(value, delay) &#123;\n      let timer;\n      return customRef((track, trigger) &#x3D;&gt; &#123;\n        return &#123;\n          get() &#123;\n            track(); &#x2F;&#x2F; 通知vue追踪数据的变化\n            return value;\n          &#125;,\n          set(newValue) &#123;\n            clearTimeout(timer);\n            value &#x3D; newValue;\n            timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n              trigger(); &#x2F;&#x2F; 通知vue去重新解析模板\n            &#125;, delay);\n          &#125;,\n        &#125;;\n      &#125;);\n    &#125;\n\n    let keyword &#x3D; myRef(&quot;&quot;, 500);</code></pre></li>\n</ul>\n</li>\n<li><p>作用：实现<strong>祖与后代组件间</strong>通信</p>\n</li>\n<li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>\n</li>\n<li><p>具体写法：</p>\n<ol>\n<li><p>祖组件中：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">setup()&#123;\n    ......\n    let car &#x3D; reactive(&#123;name:&#39;奔驰&#39;,price:&#39;40万&#39;&#125;)\n    provide(&#39;car&#39;,car)\n    ......\n&#125;</code></pre></li>\n<li><p>后代组件中：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">setup(props,context)&#123;\n    ......\n    const car &#x3D; inject(&#39;car&#39;)\n    return &#123;car&#125;\n    ......\n&#125;</code></pre></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><ul>\n<li>provide 与 inject</li>\n</ul>\n<img src=\"https://v3.cn.vuejs.org/images/components_provide.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>作用：实现<strong>祖与后代组件间</strong>通信</p>\n</li>\n<li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>\n</li>\n<li><p>具体写法：</p>\n<ol>\n<li><p>祖组件中：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">setup()&#123;\n    ......\n    let car &#x3D; reactive(&#123;name:&#39;奔驰&#39;,price:&#39;40万&#39;&#125;)\n    provide(&#39;car&#39;,car)\n    ......\n&#125;</code></pre></li>\n<li><p>后代组件中：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">setup(props,context)&#123;\n    ......\n    const car &#x3D; inject(&#39;car&#39;)\n    return &#123;car&#125;\n    ......\n&#125;</code></pre></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"新的组件\"><a href=\"#新的组件\" class=\"headerlink\" title=\"新的组件\"></a>新的组件</h3><ol>\n<li><p>Fragment</p>\n<ul>\n<li>在vue2中：组件不许有一个根标签</li>\n<li>在vue3中：组件可以没有根标签，内部会将对个标签包含在一个Fragment虚拟元素中</li>\n<li>好处：减少标签层级，减少内存占用</li>\n</ul>\n</li>\n<li><p>Teleport</p>\n<ul>\n<li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术。</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;teleport to&#x3D;&quot;移动位置&quot;&gt;\n\t&lt;div v-if&#x3D;&quot;isShow&quot; class&#x3D;&quot;mask&quot;&gt;\n\t\t&lt;div class&#x3D;&quot;dialog&quot;&gt;\n\t\t\t&lt;h3&gt;我是一个弹窗&lt;&#x2F;h3&gt;\n\t\t\t&lt;button @click&#x3D;&quot;isShow &#x3D; false&quot;&gt;关闭弹窗&lt;&#x2F;button&gt;\n\t\t&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;teleport&gt;</code></pre></li>\n</ul>\n</li>\n<li><p>Suspense</p>\n<ul>\n<li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>\n</li>\n<li><p>使用步骤：</p>\n<ul>\n<li><p>异步引入组件</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">import &#123;defineAsyncComponent&#125; from &#39;vue&#39;\nconst Child &#x3D; defineAsyncComponent(()&#x3D;&gt;import(&#39;.&#x2F;components&#x2F;Child.vue&#39;))</code></pre></li>\n<li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n    &lt;div class&#x3D;&quot;app&quot;&gt;\n        &lt;h3&gt;我是App组件&lt;&#x2F;h3&gt;\n        &lt;Suspense&gt;\n            &lt;template v-slot:default&gt;\n                &lt;Child&#x2F;&gt;\n            &lt;&#x2F;template&gt;\n            &lt;template v-slot:fallback&gt;\n                &lt;h3&gt;加载中.....&lt;&#x2F;h3&gt;\n            &lt;&#x2F;template&gt;\n        &lt;&#x2F;Suspense&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","text":"常用的Compositon APIsetup函数 理解：vue3.0中一个新的配置项，值为一个函数 setup执行的时机 在beforeCreate之前执行一次，this是undefined setup的参数 props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"vue vue3","slug":"vue-vue3","count":1,"path":"api/tags/vue-vue3.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E7%9A%84Compositon-API\"><span class=\"toc-text\">常用的Compositon API</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#setup%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">setup函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ref%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">ref函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reactive%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">reactive函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Vue3-0%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Vue3.0中的响应式原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vue2-x%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F\"><span class=\"toc-text\">vue2.x的响应式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vue3-0%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F\"><span class=\"toc-text\">vue3.0的响应式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#watchEffect%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">watchEffect函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89hook%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">自定义hook函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#toRef\"><span class=\"toc-text\">toRef</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96-Composition-API\"><span class=\"toc-text\">其他 Composition API</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">新的组件</span></a></li></ol></li></ol></li></ol>","author":{"name":"Raver233","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"無限進步","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"VsCode","uid":"8e30f2149bb0b74d970e05c27cce2051","slug":"VsCode","date":"2021-11-22T01:43:04.000Z","updated":"2021-11-22T01:47:31.726Z","comments":true,"path":"api/articles/VsCode.json","keywords":"無限進步","cover":null,"text":"快捷键 选中编辑代码中相同的内容 command/ctrl+shift+L ","link":"","photos":[],"count_time":{"symbolsCount":39,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Raver233","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"無限進步","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"vue学习笔记","uid":"a6ae49244c61aefa5ffa97d9544305fe","slug":"vue学习笔记","date":"2021-11-07T08:06:12.000Z","updated":"2022-04-30T16:19:40.486Z","comments":true,"path":"api/articles/vue学习笔记.json","keywords":"無限進步","cover":null,"text":"基础$nextTick作用：在下一次DOM更新结束后执行其指定的回调 用法：常用于改变数据后，要基于更新后的DOM进行某些操作时，要在nextTick的回调中执行 &#x2F;&#x2F; 语法 this.$nextTick(callback()) 路由生命周期钩子activat...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"vue","slug":"vue","count":1,"path":"api/tags/vue.json"}],"author":{"name":"Raver233","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"無限進步","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}